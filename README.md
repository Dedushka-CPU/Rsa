---
# Общие сведения

В данном репозитории находятся файлы с реализацией шифрования **RSA** на языке C++. Проект включает в себя основные компоненты для генерации ключей, шифрования и расшифрования сообщений.

## Список файлов

- `Rsa.cpp`
- `Rsa2_0.cpp`
- `Rsa_Class/main.cpp`
- `Rsa_Class/Rsa.h`

## Описание файлов

### Rsa.cpp

> Этот файл содержит основную логику для шифрования и расшифрования с использованием RSA.

1. **Подключение библиотек**
   ```cpp
   #include <iostream>
   #include <string>
   #include <vector>
   #include <random> 
   #include <cstdint>
   ```
   Данная часть кода подключает необходимые библиотеки для работы с вводом/выводом, строками, векторами и случайными числами.

2. **Алгоритм Евклида для нахождения НОД**
   ```cpp
   uint64_t Nod(uint64_t a, uint64_t b) {
       uint64_t temp;
       while (b != 0) {
           temp = b;
           b = a % b;
           a = temp;
       }
       return a;
   }
   ```
   Функция `Nod` вычисляет наибольший общий делитель (НОД) двух чисел.

3. **Генерация ключей**
   ```cpp
   void generateKey(uint64_t& e, uint64_t& d, uint64_t& n) {
       std::vector<uint64_t> primes = {
           // Список простых чисел...
       };

       std::random_device rd;
       std::mt19937 gen(rd());
       std::uniform_int_distribution<> distrib(0, primes.size() - 1);

       uint64_t p = primes[distrib(gen)];
       uint64_t q;

       do {
           q = primes[distrib(gen)];
       } while (p == q);

       n = p * q;
       uint64_t phi = (p - 1) * (q - 1);

       e = 3;
       while (Nod(e, phi) != 1) {
           e++;
       }

       uint64_t k = 1;
       while ((1 + k * phi) % e != 0) {
           k++;
       }
       d = (1 + k * phi) / e;
   }
   ```
   Функция `generateKey` создает открытый (e, n) и закрытый (d) ключи для шифрования и расшифрования. Она выбирает два различных простых числа из предопределенного списка и вычисляет необходимые значения.

4. **Возведение в степень по модулю**
   ```cpp
   uint64_t PowNum(uint64_t base, uint64_t exp, uint64_t mod) {
       uint64_t res = 1;
       while (exp > 0) {
           if (exp % 2 == 1) {
               res = (res * base) % mod;
           }
           base = (base * base) % mod;
           exp /= 2;
       }
       return res;
   }
   ```
   Функция `PowNum` реализует эффективный алгоритм возведения в степень с использованием метода бинарного разбиения, позволяя производить вычисления по модулю.

5. **Шифрование сообщения**
   ```cpp
   std::vector<uint64_t> Rsa(const std::string& mes, uint64_t e, uint64_t n) {
       std::vector<uint64_t> MesASCII;
       for (char c : mes) {
           uint64_t num = static_cast<uint64_t>(c);
           MesASCII.push_back(PowNum(num, e, n));
       }
       return MesASCII;
   }
   ```
   Функция `Rsa` преобразует строку сообщения в вектор чисел, используя открытый ключ для шифрования каждого символа в его ASCII-значение.

6. **Расшифрование сообщения**
   ```cpp
   std::string DeRsa(const std::vector<uint64_t>& mes, uint64_t d, uint64_t n) {
       std::string MesASCII;
       for (uint64_t c : mes) {
           uint64_t num = PowNum(c, d, n);
           MesASCII += static_cast<char>(num);
       }
       return MesASCII;
   }
   ```
   Функция `DeRsa` принимает зашифрованное сообщение в виде вектора и использует закрытый ключ для восстановления исходного текста.

---
### Rsa2_0.cpp
> Почти идентичный файл Rsa.cpp
### Подключение библиотек

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <random> // для генерации случайных чисел
#include <cstdint> // для использования типа uint64_t
```

Код использует стандартные библиотеки C++ для работы с вводом/выводом, строками и векторами, а также для генерации случайных чисел.

### Функции

1. **Возведение в степень по модулю**
   ```cpp
   uint64_t PowNum(uint64_t base, uint64_t exp, uint64_t mod) {
       uint64_t res = 1;
       while (exp > 0) {
           if (exp % 2 == 1) {
               res = (res * base) % mod;
           }
           base = (base * base) % mod;
           exp /= 2;
       }
       return res;
   }
   ```
   Функция `PowNum` выполняет эффективное возведение числа в степень с использованием метода бинарного разбиения, что позволяет производить вычисления по модулю.

2. **Нахождение НОД**
   ```cpp
   uint64_t Nod(uint64_t a, uint64_t b) {
       uint64_t temp;
       while (b != 0) {
           temp = b;
           b = a % b;
           a = temp;
       }
       return a;
   }
   ```
   Функция `Nod` реализует алгоритм Евклида для вычисления наибольшего общего делителя (НОД) двух чисел.

3. **Тест Миллера-Рабина**
   ```cpp
   bool millerRabin(uint64_t n, int iterations = 5) {
       // Проверка на простоту с помощью теста Миллера-Рабина
   }
   ```
   Функция `millerRabin` проверяет, является ли число `n` простым с использованием стохастического теста Миллера-Рабина. Функция возвращает `true`, если число вероятно простое, и `false` в противном случае.

4. **Поиск большого простого числа**
   ```cpp
   uint64_t findLargePrime(int bitLength) {
       // Генерация случайного большого простого числа
   }
   ```
   Функция `findLargePrime` генерирует случайное большое простое число заданной длины в битах с использованием теста Миллера-Рабина для проверки простоты.

5. **Генерация ключей**
   ```cpp
   void generateKey(uint64_t& e, uint64_t& d, uint64_t& n) {
       // Генерация открытого и закрытого ключей
   }
   ```
   Функция `generateKey` создает открытый ключ (e, n) и закрытый ключ (d) для шифрования и расшифрования. Она использует два больших простых числа, которые генерируются с помощью функции `findLargePrime`.

6. **Шифрование сообщения**
   ```cpp
   std::vector<uint64_t> Rsa(const std::string& mes, uint64_t e, uint64_t n) {
       // Шифрование сообщения с использованием открытого ключа
   }
   ```
   Функция `Rsa` преобразует строку сообщения в вектор чисел, шифруя каждый символ, используя открытый ключ.

7. **Расшифрование сообщения**
   ```cpp
   std::string DeRsa(const std::vector<uint64_t>& mes, uint64_t d, uint64_t n) {
       // Расшифрование сообщения с использованием закрытого ключа
   }
   ```
   Функция `DeRsa` принимает зашифрованное сообщение в виде вектора и восстанавливает исходный текст с использованием закрытого ключа.

### Основная функция

```cpp
int main() {
    std::string message;
    std::getline(cin, message);

    uint64_t e, d, n;
    cout << "Your message: " << message << "\n";

    generateKey(e, d, n);
    cout << "e: " << e << "\n" << "d: " << d << "\n" << "n: " << n << "\n";

    std::vector<uint64_t> mess = Rsa(message, e, n);
    cout << "After Rsa:\n";
    for (uint64_t c : mess) {
        cout << c;
    }
    std::string DeRsaMes = DeRsa(mess, d, n);
    cout << "\nAfter DeRsa:\n" << DeRsaMes << "\n";

    return 0;
}
```

В `main`-функции происходит:
- Ввод сообщения от пользователя.
- Генерация ключей (e, d, n) с использованием функции `generateKey`.
- Шифрование введенного сообщения с помощью функции `Rsa`.
- Вывод зашифрованного сообщения.
- Расшифрование и вывод восстановленного сообщения с помощью функции `DeRsa`.

---
### Rsa.h

> Класс `BigNum` предназначен для работы с большими целыми числами, которые могут превышать стандартный размер типов данных, таких как `uint64_t`. Он использует вектор `std::vector<uint64_t>` для хранения данных, что позволяет работать с числами произвольной длины.

#### Конструкторы

- `BigNum(const std::string& number)`: Конструктор, принимающий строку, представляющую большое число. Он использует метод `parseString` для преобразования строки в объект `BigNum`.
  
- `BigNum(uint64_t value)`: Конструктор, принимающий 64-битное целое число. Если значение больше 0, оно добавляется в вектор `data`.

- `BigNum(char c)`: Конструктор, который принимает символ и добавляет его ASCII-код в вектор `data`.

- `BigNum(int value)`: Конструктор, принимающий целое число. Если значение отрицательное, выбрасывается исключение. Если положительное, оно добавляется в `data`.

#### Методы

- `uint64_t toUInt() const`: Преобразует объект `BigNum` в 64-битное целое число. Он проходит по всем элементам вектора `data` и вычисляет итоговое значение.

- `char toChar() const`: Преобразует объект `BigNum` в символ. Если число выходит за пределы допустимого диапазона для символа, выбрасывается исключение.

- `BigNum operator+`: Перегруженный оператор сложения, который складывает два объекта `BigNum` и возвращает результат.

- `BigNum operator-`: Перегруженный оператор вычитания, который вычитает одно число из другого. Если результат отрицательный, выбрасывается исключение.

- `BigNum operator*`: Перегруженный оператор умножения, который умножает два объекта `BigNum`.

- `std::pair<BigNum, uint64_t> divide(const BigNum& divisor) const`: Метод, который выполняет деление `BigNum` на другой `BigNum`. Возвращает частное и остаток.

- `bool operator<`: Перегруженный оператор сравнения, который проверяет, меньше ли текущее число другого числа.

- `bool operator==`: Перегруженный оператор равенства.

- `bool isZero() const`: Проверяет, равно ли текущее число нулю.

- `void print() const`: Выводит текущее значение `BigNum` в стандартный вывод. 

- `BigNum parseString(const std::string& number) const`: Преобразует строку в объект `BigNum`, умножая на 10 и добавляя значения символов.

- `uint64_t divideBy10()`: Делит текущее число на 10 и возвращает остаток.

#### Статические методы

- `static BigNum Nod(BigNum a, BigNum b)`: Статический метод для нахождения наибольшего общего делителя (НОД) двух чисел.

- `static BigNum PowNum(BigNum base, BigNum exp, BigNum mod)`: Статический метод для вычисления степени с модулем.

### main.cpp
> Основной файл в котором кодируется в Rsa и обратно.Работает с помощью класса BigNum.

1. **Функция `generateKey`** — отвечает за генерацию открытого и закрытого ключей:
   - Создает два больших простых числа `p` и `q`, которые позже используются для вычисления модуля `n` RSA. В данном коде `p` и `q` заданы конкретными значениями для теста, но закомментированный код показывает, как можно было бы выбрать случайные простые числа из списка.
   - Вычисляется модуль `n` как произведение `p * q`, который используется как часть открытого и закрытого ключей.
   - Затем вычисляется значение функции Эйлера `phi = (p - 1) * (q - 1)`.
   - Начальное значение открытого показателя `e` устанавливается на `3`, и, пока `e` и `phi` не взаимно простые (определяется функцией `BigNum::Nod`), значение `e` увеличивается на 1.
   - Наконец, для закрытого ключа `d` ищется значение, которое удовлетворяет уравнению \((1 + k * phi) \mod e = 0\) для некоторого `k`, и `d` вычисляется как \((1 + k * phi) / e\).

2. **Функция `Rsa`** — шифрует сообщение:
   - Проходит по каждому символу строки `mes`, конвертирует его в `BigNum`, и вычисляет его зашифрованное значение как \(num^e \mod n\) с помощью `BigNum::PowNum`.
   - Возвращает массив зашифрованных значений для каждого символа.

3. **Функция `DeRsa`** — дешифрует сообщение:
   - Получает зашифрованное сообщение в виде вектора объектов `BigNum`.
   - Каждый элемент возводится в степень `d` по модулю `n`, что позволяет получить ASCII-коды символов оригинального сообщения.
   - Конвертирует каждый результат обратно в символ с помощью `num.toChar()` и добавляет его в строку `MesASCII`.
   - Возвращает расшифрованное сообщение.

4. **Функция `main`**:
   - Инициализирует переменные `e`, `d`, и `n` для хранения ключей.
   - Вызывает `generateKey`, чтобы создать открытый и закрытый ключи и выводит их.
   - Создает строку для шифрования, шифрует её с помощью функции `Rsa`, выводит зашифрованное сообщение и затем дешифрует его с помощью функции `DeRsa`.
   - Выводит расшифрованное сообщение на экран.

Пример вывода:
1. Выводится сгенерированное значение модуля `n`, открытый показатель `e` и закрытый показатель `d`.
2. Шифруется строка "Hello", выводится её зашифрованный вид в виде чисел.
3. Дешифрованное сообщение выводится как строка, совпадающая с оригиналом ("Hello").
---
## Пример использования
Для примера `p=503,q=509`.Сообщение для кодирвоки:`Hello, world!`
```cpp
n=256027
phi=255016
e=3
k=2
d=170011
Public exponent (e): 3
Private exponent (d): 170011
Modulus (n): 256027
Num cod:117221
Num cod:6193
Num cod:235604
Num cod:235604
Num cod:87496
Num cod:85184
Num cod:32768
Num cod:148997
Num cod:87496
Num cod:201409
Num cod:235604
Num cod:231919
Num cod:35937
Encrypted message:
117221 6193 235604 235604 87496 85184 32768 148997 87496 201409 235604 231919 35937
Num Decod:72
Num Decod:101
Num Decod:108
Num Decod:108
Num Decod:111
Num Decod:44
Num Decod:32
Num Decod:119
Num Decod:111
Num Decod:114
Num Decod:108
Num Decod:100
Num Decod:33
Decrypted message: Hello, world!
```
